# MeshNet Audio v0.1 Implementation Plan

**Date:** October 19, 2025  
**Status:** Ready for Implementation

## Overview

This document outlines the implementation plan for MeshNet Audio v0.1 prototype. The goal is to build a working wireless audio system with one TX (transmitter) and one RX (receiver) unit.

## Current State Assessment

### What's Working
- **Network Layer**: Basic AP init (TX), STA init (RX), UDP broadcast send/receive, RSSI reading
- **Audio Layer**: Tone generator (440 Hz), I2S initialization and write
- **Control Layer**: Button polling with basic short/long press detection
- **Build System**: PlatformIO with separate TX/RX environments, proper sdkconfig defaults

### What's Stubbed/Missing
- **Network**: Latency measurement, connected nodes count, WiFi event handling, power-save management
- **Audio**: USB audio (fully stubbed), RX jitter buffer (ring buffer exists but unused), aux ADC input
- **Control**: SSD1306 display rendering (only stub logging), button debouncing

### Known Issues
- I2S configured as mono; UDA1334 DAC expects stereo or 32-bit slots
- RX bandwidth calculation incorrect
- No WiFi wait-for-IP on RX before binding UDP socket
- No power-save disable for low latency

## v0.1 Goals & Priorities

### Minimum Viable Demo
1. **Tone → Network → I2S Audio** (get sound working)
2. **USB Audio Input** (primary input mode)
3. **Basic Display & Controls** (status visibility)
4. **Aux Input** (time permitting)

### Technical Specifications
- **Audio Format**: 16 kHz, 16-bit mono PCM
- **Frame Size**: 10 ms (160 samples, 320 bytes)
- **Network**: UDP broadcast over WiFi AP/STA (single-hop)
- **Latency Target**: <60 ms startup, minimal audio glitches

## Implementation Phases

### Phase A: Baseline Fixes (Priority: High, Effort: 1-2h)

**Network Stability**
- [ ] RX: Add WiFi connection wait loop using `esp_wifi_sta_get_ap_info()`
- [ ] RX: Disable power-save with `esp_wifi_set_ps(WIFI_PS_NONE)` after connect
- [ ] Fix bandwidth calculation using proper tick tracking and elapsed time

**Code Locations:**
- `lib/network/src/mesh_net.c` - `network_init_sta()`
- `src/rx/main.c` - bandwidth calc in main loop

### Phase B: First Sound - Tone → UDP → I2S (Priority: High, Effort: 2-4h)

**TX Changes**
- [ ] Keep `INPUT_MODE_TONE` as default
- [ ] Simplify main loop (remove unused ring buffer for now)
- [ ] Optional: Add 4-byte sequence counter to packets for debugging

**RX Changes - I2S Stereo Support**
- [ ] Update I2S slot config to `I2S_SLOT_MODE_STEREO`
- [ ] Implement `i2s_audio_write_mono_dup()` to duplicate mono samples to stereo
- [ ] Integrate stereo duplication in RX main loop before I2S write

**Expected Result:** Hear 440 Hz tone through RX headphones/speakers

**Code Locations:**
- `lib/audio/src/i2s_audio.c` - Add stereo duplication function
- `lib/audio/include/audio/i2s_audio.h` - Add function declaration
- `src/rx/main.c` - Use new stereo write function

### Phase C: RX Jitter Buffer (Priority: High, Effort: 2-4h)

**Architecture:**
- Decouple network receive from I2S playback using two tasks
- `net_rx_task`: Receive UDP packets → validate → write to ring buffer
- `dac_task`: Every 10 ms, read one frame from ring buffer → write to I2S
- Implement prefill threshold (wait for 3+ frames before starting playback)

**Implementation:**
- [ ] Create `net_rx_task` with UDP receive loop
- [ ] Create `dac_task` with timed I2S write loop
- [ ] Configure ring buffer for 8-12 frame capacity
- [ ] Implement prefill logic and underrun handling (write silence on empty)
- [ ] Add underrun/overrun counters for debugging

**Expected Result:** Smooth audio playback without glitches from network jitter

**Code Locations:**
- `src/rx/main.c` - Refactor into two tasks
- `lib/audio/src/ring_buffer.c` - Add `try_read_exact()` if needed

### Phase D: USB Audio Input (Priority: High, Effort: 1-2 days)

**Requirements:**
- TinyUSB UAC1 speaker interface (PC → Device audio OUT)
- Mono, 16 kHz, 16-bit only (no resampling in v0.1)
- USB RX ring buffer to decouple isochronous packets from network send

**Implementation:**
- [ ] Configure TinyUSB device stack with UAC1 OUT endpoint
- [ ] Create USB audio descriptors for 16 kHz mono 16-bit
- [ ] Implement isochronous OUT callback → write to USB ring buffer
- [ ] Implement `usb_audio_is_active()` (check streaming interface & recent packets)
- [ ] Implement `usb_audio_read_frames()` (pull 320 bytes, return zeros if insufficient)
- [ ] Integrate into TX main loop: switch between tone and USB based on mode

**Expected Result:** Select USB input mode, play audio from computer through RX unit

**Code Locations:**
- `lib/audio/src/usb_audio.c` - Full implementation
- `lib/audio/include/audio/usb_audio.h` - API finalization
- `src/tx/main.c` - Input mode switching logic
- `sdkconfig.tx.defaults` - Verify `CONFIG_TINYUSB_ENABLED=y`, `CONFIG_TINYUSB_AUDIO_ENABLED=y`

**References:**
- TinyUSB UAC1 examples for descriptor templates
- ESP-IDF TinyUSB documentation

### Phase E: Display & Button Controls (Priority: Medium, Effort: 2-4h)

**Button Improvements**
- [ ] Add debouncing (30-50 ms stabilization)
- [ ] Test short/long press reliability

**Display Implementation**
- [ ] Initialize I2C master for SSD1306 (address 0x3C)
- [ ] Implement SSD1306 initialization sequence
- [ ] Add simple text renderer (5x7 font, text-only)
- [ ] Implement TX display views:
  - Network: "AP: Up", "Nodes: N"
  - Audio: "Mode: Tone/USB/Aux", "Status: Streaming/Idle"
- [ ] Implement RX display views:
  - Network: "RSSI: -XX dBm", "Latency: XX ms", "BW: XX kbps"
  - Audio: "Receiving: Yes/No", "Buffer: XX%", "Underruns: N"

**Expected Result:** Status visible on both OLED displays, button switches views and modes

**Code Locations:**
- `lib/control/src/buttons.c` - Add debouncing
- `lib/control/src/display_ssd1306.c` - Full implementation
- `lib/control/include/control/display.h` - Update API if needed
- `src/tx/main.c`, `src/rx/main.c` - Integrate display updates

### Phase F: Aux Input via PCF8591 ADC (Priority: Low, Effort: 2-4h)

**Requirements:**
- 8-bit sampling from PCF8591 over I2C
- Dedicated sampling task for `INPUT_MODE_AUX`
- Read 160 samples every 10 ms, scale to 16-bit signed
- Simple DC blocker (first-order high-pass filter)

**Implementation:**
- [ ] Create `aux_input_task` for PCF8591 reading
- [ ] Implement burst read (discard first byte after channel change)
- [ ] Scale 8-bit unsigned → 16-bit signed
- [ ] Add DC blocking filter
- [ ] Buffer frames for network transmission
- [ ] Integrate into TX main loop input switching

**Expected Result:** 1/8" aux input works as third input mode

**Code Locations:**
- New file: `lib/audio/src/aux_input.c`, `lib/audio/include/audio/aux_input.h`
- `src/tx/main.c` - Add `INPUT_MODE_AUX` handling
- `lib/config/include/config/pins.h` - Verify PCF8591 I2C pins

## Technical Details

### Audio Pipeline Architecture

**TX Unit:**
```
[Input Source] → [Ring Buffer] → [UDP Broadcast]
    ↓
Tone Gen / USB Audio / Aux ADC
```

**RX Unit:**
```
[UDP Receive] → [Jitter Buffer] → [Mono→Stereo] → [I2S DAC]
    ↓                 ↓                                ↓
net_rx_task      ring_buffer                      dac_task
```

### Network Packet Format (v0.1)

**Simple Format (Phase B-C):**
- Raw 320 bytes PCM audio data

**Enhanced Format (Optional):**
```c
struct audio_packet {
    uint32_t magic;         // 0xAUD10
    uint8_t version;        // 0x01
    uint32_t seq;           // Sequence number
    uint32_t timestamp_ms;  // Sender timestamp
    uint16_t payload_len;   // 320
    uint8_t crc8;           // Checksum
    uint8_t payload[320];   // Audio data
};
```

### I2S Configuration for UDA1334

**Required Changes:**
- Slot mode: `I2S_SLOT_MODE_STEREO`
- Slot config: Consider `I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG`
- Software duplication: `[L0, R0, L1, R1, ...]` from mono `[m0, m1, ...]`
- Alternative: 32-bit slot width if stereo duplication doesn't work

### USB Audio Configuration

**TinyUSB Descriptor Requirements:**
- Interface: Audio Control (empty)
- Interface: Audio Streaming OUT
  - Alt 0: Zero bandwidth
  - Alt 1: Isochronous OUT endpoint
    - Format: PCM, 16 kHz, 1 channel, 16-bit
    - Packet size: 32 bytes (2 ms) - adjust as needed for host compatibility

### Jitter Buffer Parameters

**Ring Buffer Configuration:**
- Capacity: 8-12 frames (80-120 ms)
- Prefill threshold: 3 frames (30 ms)
- Underrun handling: Write silence frame
- Target latency: 40-60 ms typical

**Adaptive Behavior (Future):**
- Track late packet rate
- Adjust target depth dynamically
- Implement sample dropping/duplication for clock drift

## Known Limitations & Risks

### I2S Stereo Issue
**Risk:** No audio output or only one channel  
**Mitigation:** Ensure stereo slot mode and proper duplication, or try 32-bit slot width

### USB Audio Drift
**Risk:** Long sessions may drift without feedback endpoint  
**Mitigation:** Keep v0.1 sessions short, document issue, implement periodic sample drop/dup if needed

### WiFi Jitter
**Risk:** Power-save mode increases jitter and latency  
**Mitigation:** Disable power-save on RX with `WIFI_PS_NONE`, increase jitter buffer if needed

### PCF8591 Quality
**Risk:** 8-bit ADC with I2C jitter may produce noisy audio  
**Mitigation:** Acceptable for demo, reduce gain, consider dropping if time-limited

### Bandwidth
**Calculation:** 16 kHz × 16-bit × 1 channel = 256 kbps raw = 25.6 kbps per frame  
**Status:** Trivial for WiFi, no compression needed in v0.1

## Testing Plan

### Phase Testing

**Phase A - Baseline:**
- [ ] Verify RX connects to TX AP reliably
- [ ] Confirm power-save disabled (check WiFi config)
- [ ] Validate bandwidth calculation with known packet rate

**Phase B - First Sound:**
- [ ] Hear 440 Hz tone on RX output
- [ ] Verify stereo output on both channels
- [ ] Check for pops, clicks, or distortion

**Phase C - Jitter Buffer:**
- [ ] Monitor underrun counter
- [ ] Test with simulated network jitter (delay packets)
- [ ] Verify smooth playback under load

**Phase D - USB Audio:**
- [ ] Connect to Windows/Mac/Linux hosts
- [ ] Verify device enumeration as audio output
- [ ] Play various audio sources (music, speech, tones)
- [ ] Test mode switching between tone and USB

**Phase E - Display:**
- [ ] Verify all views render correctly
- [ ] Test button short/long press switching
- [ ] Validate displayed metrics (RSSI, bandwidth, etc.)

**Phase F - Aux Input:**
- [ ] Test with various audio sources (phone, laptop, etc.)
- [ ] Verify DC blocking removes bias
- [ ] Check audio quality vs USB/tone

### Integration Testing
- [ ] Rapid mode switching on TX
- [ ] Rapid view switching on both units
- [ ] Extended playback session (5+ minutes)
- [ ] Power cycle recovery
- [ ] Maximum range test

## v0.1 Exit Criteria

### Minimum Requirements
- ✅ TX generates tone and transmits via UDP
- ✅ RX receives UDP and plays audio via I2S
- ✅ USB audio input works as primary mode
- ✅ Display shows basic status on both units
- ✅ Buttons switch views and input modes
- ✅ Audio startup latency <60 ms
- ✅ Minimal pops, clicks, or glitches during playback

### Stretch Goals
- ✅ Aux input working via PCF8591
- ✅ Latency measurement and display
- ✅ Packet loss statistics
- ✅ Multiple RX units supported

### Documentation Required
- [ ] Updated AGENTS.md with build/test instructions
- [ ] User guide for operation
- [ ] Known issues and workarounds
- [ ] v0.2 feature roadmap

## Future Enhancements (Post v0.1)

### Advanced Network
- True ESP-MESH or ESP-NOW for multi-hop
- Packet header with seq, timestamp, CRC
- Unicast streams instead of broadcast
- FEC or retransmission for reliability

### Advanced Audio
- Time-stamped packets with PLL-like clock recovery
- Adaptive jitter buffer with depth control
- Packet loss concealment (PLC)
- Sample rate conversion for USB sources
- Stereo support (44.1/48 kHz)

### Advanced Control
- Graphical OLED views (waveforms, spectrum)
- Web interface for configuration
- MQTT status reporting
- Multi-language support

### Hardware Improvements
- Better ADC for aux input (16-bit I2S ADC)
- Battery power with charge management
- Enclosure design
- Multiple RX units with pairing system

## References

- [ESP-IDF I2S Documentation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-reference/peripherals/i2s.html)
- [TinyUSB Documentation](https://docs.tinyusb.org/)
- [UDA1334 Datasheet](https://www.nxp.com/docs/en/data-sheet/UDA1334ATS.pdf)
- [ESP32-S3 Technical Reference](https://www.espressif.com/sites/default/files/documentation/esp32-s3_technical_reference_manual_en.pdf)
- [PCF8591 Datasheet](https://www.nxp.com/docs/en/data-sheet/PCF8591.pdf)

## Effort Estimates

| Phase | Priority | Effort | Duration |
|-------|----------|--------|----------|
| A: Baseline Fixes | High | Small | 1-2h |
| B: First Sound | High | Small-Medium | 2-4h |
| C: Jitter Buffer | High | Medium | 2-4h |
| D: USB Audio | High | Large | 1-2d |
| E: Display & Controls | Medium | Medium | 2-4h |
| F: Aux Input | Low | Medium | 2-4h |

**Total Estimated Effort:** 3-5 days of focused development

## Next Steps

1. Review this plan and adjust priorities if needed
2. Begin with Phase A (baseline fixes)
3. Proceed sequentially through phases B-E
4. Add Phase F (aux input) if time permits
5. Conduct integration testing
6. Document findings and update for v0.2

---

*Plan created by AI Oracle with input from project requirements and codebase analysis*
